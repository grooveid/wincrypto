// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package bcrypt

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return nil
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modbcrypt = windows.NewLazySystemDLL("bcrypt.dll")

	procBCryptOpenAlgorithmProvider  = modbcrypt.NewProc("BCryptOpenAlgorithmProvider")
	procBCryptCloseAlgorithmProvider = modbcrypt.NewProc("BCryptCloseAlgorithmProvider")
	procBCryptCreateHash             = modbcrypt.NewProc("BCryptCreateHash")
	procBCryptDecrypt                = modbcrypt.NewProc("BCryptDecrypt")
	procBCryptDeriveKey              = modbcrypt.NewProc("BCryptDeriveKey")
	procBCryptDestroyHash            = modbcrypt.NewProc("BCryptDestroyHash")
	procBCryptDestroyKey             = modbcrypt.NewProc("BCryptDestroyKey")
	procBCryptDestroySecret          = modbcrypt.NewProc("BCryptDestroySecret")
	procBCryptDuplicateHash          = modbcrypt.NewProc("BCryptDuplicateHash")
	procBCryptDuplicateKey           = modbcrypt.NewProc("BCryptDuplicateKey")
	procBCryptEncrypt                = modbcrypt.NewProc("BCryptEncrypt")
	procBCryptExportKey              = modbcrypt.NewProc("BCryptExportKey")
	procBCryptFinalizeKeyPair        = modbcrypt.NewProc("BCryptFinalizeKeyPair")
	procBCryptFinishHash             = modbcrypt.NewProc("BCryptFinishHash")
	procBCryptFreeBuffer             = modbcrypt.NewProc("BCryptFreeBuffer")
	procBCryptGenerateKeyPair        = modbcrypt.NewProc("BCryptGenerateKeyPair")
	procBCryptGenerateSymmetricKey   = modbcrypt.NewProc("BCryptGenerateSymmetricKey")
	procBCryptGenRandom              = modbcrypt.NewProc("BCryptGenRandom")
	procBCryptGetProperty            = modbcrypt.NewProc("BCryptGetProperty")
	procBCryptHash                   = modbcrypt.NewProc("BCryptHash")
	procBCryptHashData               = modbcrypt.NewProc("BCryptHashData")
	procBCryptImportKey              = modbcrypt.NewProc("BCryptImportKey")
	procBCryptImportKeyPair          = modbcrypt.NewProc("BCryptImportKeyPair")
	procBCryptKeyDerivation          = modbcrypt.NewProc("BCryptKeyDerivation")
	procBCryptSecretAgreement        = modbcrypt.NewProc("BCryptSecretAgreement")
	procBCryptSetProperty            = modbcrypt.NewProc("BCryptSetProperty")
	procBCryptSignHash               = modbcrypt.NewProc("BCryptSignHash")
	procBCryptVerifySignature        = modbcrypt.NewProc("BCryptVerifySignature")
)

func BCryptOpenAlgorithmProvider(algorithm *BCRYPT_ALG_HANDLE, pszAlgId *uint16, pszImplementation *uint16, flags int32) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall6(procBCryptOpenAlgorithmProvider.Addr(), 4, uintptr(unsafe.Pointer(algorithm)), uintptr(unsafe.Pointer(pszAlgId)), uintptr(unsafe.Pointer(pszImplementation)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptCloseAlgorithmProvider(algorithm BCRYPT_ALG_HANDLE, flags uintptr) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall(procBCryptCloseAlgorithmProvider.Addr(), 2, uintptr(algorithm), uintptr(flags), 0)
	s = NTSTATUS(r0)
	return
}

func BCryptCreateHash(algorithm BCRYPT_ALG_HANDLE, hash *BCRYPT_HASH_HANDLE, hashObject []byte, secret []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(hashObject) > 0 {
		_p0 = &hashObject[0]
	}
	var _p1 *byte
	if len(secret) > 0 {
		_p1 = &secret[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptCreateHash.Addr(), 7, uintptr(algorithm), uintptr(unsafe.Pointer(hash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(hashObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(secret)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDecrypt(key BCRYPT_KEY_HANDLE, input []byte, paddingInfo uintptr, iv []byte, output []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(input) > 0 {
		_p0 = &input[0]
	}
	var _p1 *byte
	if len(iv) > 0 {
		_p1 = &iv[0]
	}
	var _p2 *byte
	if len(output) > 0 {
		_p2 = &output[0]
	}
	r0, _, _ := syscall.Syscall12(procBCryptDecrypt.Addr(), 10, uintptr(key), uintptr(unsafe.Pointer(_p0)), uintptr(len(input)), uintptr(paddingInfo), uintptr(unsafe.Pointer(_p1)), uintptr(len(iv)), uintptr(unsafe.Pointer(_p2)), uintptr(len(output)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDeriveKey(sharedSecret BCRYPT_SECRET_HANDLE, pwszKDF *uint16, parameterList *BCryptBufferDesc, derivedKey []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(derivedKey) > 0 {
		_p0 = &derivedKey[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptDeriveKey.Addr(), 7, uintptr(sharedSecret), uintptr(unsafe.Pointer(pwszKDF)), uintptr(unsafe.Pointer(parameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(derivedKey)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDestroyHash(hash BCRYPT_HASH_HANDLE) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyHash.Addr(), 1, uintptr(hash), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDestroyKey(key BCRYPT_KEY_HANDLE) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall(procBCryptDestroyKey.Addr(), 1, uintptr(key), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDestroySecret(secret BCRYPT_SECRET_HANDLE) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall(procBCryptDestroySecret.Addr(), 1, uintptr(secret), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDuplicateHash(hash BCRYPT_HASH_HANDLE, newHash *BCRYPT_HASH_HANDLE, hashObject []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(hashObject) > 0 {
		_p0 = &hashObject[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptDuplicateHash.Addr(), 5, uintptr(hash), uintptr(unsafe.Pointer(newHash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(hashObject)), uintptr(flags), 0)
	s = NTSTATUS(r0)
	return
}

func BCryptDuplicateKey(key BCRYPT_KEY_HANDLE, newKey *BCRYPT_KEY_HANDLE, keyObject []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(keyObject) > 0 {
		_p0 = &keyObject[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptDuplicateKey.Addr(), 5, uintptr(key), uintptr(unsafe.Pointer(newKey)), uintptr(unsafe.Pointer(_p0)), uintptr(len(keyObject)), uintptr(flags), 0)
	s = NTSTATUS(r0)
	return
}

func BCryptEncrypt(key BCRYPT_KEY_HANDLE, input []byte, pPaddingInfo uintptr, iv []byte, output []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(input) > 0 {
		_p0 = &input[0]
	}
	var _p1 *byte
	if len(iv) > 0 {
		_p1 = &iv[0]
	}
	var _p2 *byte
	if len(output) > 0 {
		_p2 = &output[0]
	}
	r0, _, _ := syscall.Syscall12(procBCryptEncrypt.Addr(), 10, uintptr(key), uintptr(unsafe.Pointer(_p0)), uintptr(len(input)), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p1)), uintptr(len(iv)), uintptr(unsafe.Pointer(_p2)), uintptr(len(output)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptExportKey(key BCRYPT_KEY_HANDLE, exportKey BCRYPT_KEY_HANDLE, pszBlobType *uint16, output []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(output) > 0 {
		_p0 = &output[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptExportKey.Addr(), 7, uintptr(key), uintptr(exportKey), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(_p0)), uintptr(len(output)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptFinalizeKeyPair(key BCRYPT_KEY_HANDLE, flags uintptr) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall(procBCryptFinalizeKeyPair.Addr(), 2, uintptr(key), uintptr(flags), 0)
	s = NTSTATUS(r0)
	return
}

func BCryptFinishHash(hash BCRYPT_HASH_HANDLE, output []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(output) > 0 {
		_p0 = &output[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptFinishHash.Addr(), 4, uintptr(hash), uintptr(unsafe.Pointer(_p0)), uintptr(len(output)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptFreeBuffer(pvBuffer uintptr) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall(procBCryptFreeBuffer.Addr(), 1, uintptr(pvBuffer), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptGenerateKeyPair(algorithm BCRYPT_ALG_HANDLE, hash *BCRYPT_KEY_HANDLE, length uintptr, flags uintptr) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall6(procBCryptGenerateKeyPair.Addr(), 4, uintptr(algorithm), uintptr(unsafe.Pointer(hash)), uintptr(length), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptGenerateSymmetricKey(algorithm BCRYPT_ALG_HANDLE, hash *BCRYPT_KEY_HANDLE, keyObject []byte, secret []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(keyObject) > 0 {
		_p0 = &keyObject[0]
	}
	var _p1 *byte
	if len(secret) > 0 {
		_p1 = &secret[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptGenerateSymmetricKey.Addr(), 7, uintptr(algorithm), uintptr(unsafe.Pointer(hash)), uintptr(unsafe.Pointer(_p0)), uintptr(len(keyObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(secret)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptGenRandom(algorithm BCRYPT_ALG_HANDLE, pbBuffer []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(pbBuffer) > 0 {
		_p0 = &pbBuffer[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptGenRandom.Addr(), 4, uintptr(algorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(pbBuffer)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptGetProperty(object BCRYPT_HANDLE, pszProperty *uint16, output []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(output) > 0 {
		_p0 = &output[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptGetProperty.Addr(), 6, uintptr(object), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(output)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags))
	s = NTSTATUS(r0)
	return
}

func BCryptHash(algorithm BCRYPT_ALG_HANDLE, secret []byte, input []byte, output []byte) (s NTSTATUS) {
	var _p0 *byte
	if len(secret) > 0 {
		_p0 = &secret[0]
	}
	var _p1 *byte
	if len(input) > 0 {
		_p1 = &input[0]
	}
	var _p2 *byte
	if len(output) > 0 {
		_p2 = &output[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptHash.Addr(), 7, uintptr(algorithm), uintptr(unsafe.Pointer(_p0)), uintptr(len(secret)), uintptr(unsafe.Pointer(_p1)), uintptr(len(input)), uintptr(unsafe.Pointer(_p2)), uintptr(len(output)), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptHashData(hash BCRYPT_HASH_HANDLE, input []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(input) > 0 {
		_p0 = &input[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptHashData.Addr(), 4, uintptr(hash), uintptr(unsafe.Pointer(_p0)), uintptr(len(input)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptImportKey(algorithm BCRYPT_ALG_HANDLE, importKey *BCRYPT_KEY_HANDLE, pszBlobType *uint16, key *BCRYPT_KEY_HANDLE, keyObject []byte, input []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(keyObject) > 0 {
		_p0 = &keyObject[0]
	}
	var _p1 *byte
	if len(input) > 0 {
		_p1 = &input[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptImportKey.Addr(), 9, uintptr(algorithm), uintptr(unsafe.Pointer(importKey)), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(_p0)), uintptr(len(keyObject)), uintptr(unsafe.Pointer(_p1)), uintptr(len(input)), uintptr(flags))
	s = NTSTATUS(r0)
	return
}

func BCryptImportKeyPair(algorithm BCRYPT_ALG_HANDLE, importKey *BCRYPT_KEY_HANDLE, pszBlobType *uint16, key *BCRYPT_KEY_HANDLE, input []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(input) > 0 {
		_p0 = &input[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptImportKeyPair.Addr(), 7, uintptr(algorithm), uintptr(unsafe.Pointer(importKey)), uintptr(unsafe.Pointer(pszBlobType)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(_p0)), uintptr(len(input)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptKeyDerivation(key BCRYPT_KEY_HANDLE, parameterList *BCryptBufferDesc, dervicedKey []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(dervicedKey) > 0 {
		_p0 = &dervicedKey[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptKeyDerivation.Addr(), 6, uintptr(key), uintptr(unsafe.Pointer(parameterList)), uintptr(unsafe.Pointer(_p0)), uintptr(len(dervicedKey)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags))
	s = NTSTATUS(r0)
	return
}

func BCryptSecretAgreement(privKey BCRYPT_KEY_HANDLE, pubKey BCRYPT_KEY_HANDLE, secret *BCRYPT_SECRET_HANDLE, flags uintptr) (s NTSTATUS) {
	r0, _, _ := syscall.Syscall6(procBCryptSecretAgreement.Addr(), 4, uintptr(privKey), uintptr(pubKey), uintptr(unsafe.Pointer(secret)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}

func BCryptSetProperty(object BCRYPT_HANDLE, pszProperty *uint16, input []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(input) > 0 {
		_p0 = &input[0]
	}
	r0, _, _ := syscall.Syscall6(procBCryptSetProperty.Addr(), 5, uintptr(object), uintptr(unsafe.Pointer(pszProperty)), uintptr(unsafe.Pointer(_p0)), uintptr(len(input)), uintptr(flags), 0)
	s = NTSTATUS(r0)
	return
}

func BCryptSignHash(key BCRYPT_KEY_HANDLE, paddingInfo uintptr, input []byte, output []byte, cbResult *uintptr, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(input) > 0 {
		_p0 = &input[0]
	}
	var _p1 *byte
	if len(output) > 0 {
		_p1 = &output[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptSignHash.Addr(), 8, uintptr(key), uintptr(paddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(input)), uintptr(unsafe.Pointer(_p1)), uintptr(len(output)), uintptr(unsafe.Pointer(cbResult)), uintptr(flags), 0)
	s = NTSTATUS(r0)
	return
}

func BCryptVerifySignature(key BCRYPT_KEY_HANDLE, pPaddingInfo uintptr, hash []byte, signature []byte, flags uintptr) (s NTSTATUS) {
	var _p0 *byte
	if len(hash) > 0 {
		_p0 = &hash[0]
	}
	var _p1 *byte
	if len(signature) > 0 {
		_p1 = &signature[0]
	}
	r0, _, _ := syscall.Syscall9(procBCryptVerifySignature.Addr(), 7, uintptr(key), uintptr(pPaddingInfo), uintptr(unsafe.Pointer(_p0)), uintptr(len(hash)), uintptr(unsafe.Pointer(_p1)), uintptr(len(signature)), uintptr(flags), 0, 0)
	s = NTSTATUS(r0)
	return
}
