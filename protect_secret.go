package wincrypto

import (
	"syscall"
	"unsafe"

	"github.com/grooveid/wincrypto/cryptosyscall"
)

// ProtectSecret encrypts plaintext. The ciphertext can be passed back to
// UnprotectSecret only on the same machine, by the same user.
//
// Where available this uses the NCryptProtectSecret Windows API, or if not
// available, CryptProtectData.
//
// In general, these APIs mean that that data protected in this way would
// not be discoverable by disk imaging. On some systems this means the secret
// is derived from the logon passwords. On other systems, cryptographic hardware
// (a TPM) may be installed (see https://docs.microsoft.com/en-us/windows/device-security/tpm/how-windows-uses-the-tpm)
//
// Note: it would be handy to know via the API when a TPM is available and
// when the secret is backed by only a key derived from the password, but I'm
// not aware of a way to do this right now.
func ProtectSecret(plaintext []byte) ([]byte, error) {
	if !cryptosyscall.HaveNCrypt() {
		return legacyProtectSecret(plaintext)
	}

	descriptorString, err := syscall.UTF16PtrFromString("LOCAL=user")
	if err != nil {
		return nil, err
	}

	var handle cryptosyscall.NCRYPT_DESCRIPTOR_HANDLE
	status := cryptosyscall.NCryptCreateProtectionDescriptor(descriptorString, 0, &handle)
	if !status.Success() {
		return nil, status
	}
	defer cryptosyscall.NCryptCloseProtectionDescriptor(handle)

	var pbOutput uintptr
	var chOutput uintptr
	status = cryptosyscall.NCryptProtectSecret(
		handle, cryptosyscall.NCRYPT_SILENT_FLAG, plaintext, nil, 0, &pbOutput, &chOutput)
	if !status.Success() {
		return nil, status
	}
	defer cryptosyscall.LocalFree(pbOutput)

	ciphertext := copyBuffer(unsafe.Pointer(pbOutput), chOutput)
	return ciphertext, nil
}

// UnprotectSecret decrypts a ciphertext generated by ProtectSecret.
func UnprotectSecret(ciphertext []byte) ([]byte, error) {
	if !cryptosyscall.HaveNCrypt() {
		return legacyUnprotectSecret(ciphertext)
	}

	descriptorString, err := syscall.UTF16PtrFromString("LOCAL=user")
	if err != nil {
		return nil, err
	}

	var handle cryptosyscall.NCRYPT_DESCRIPTOR_HANDLE
	status := cryptosyscall.NCryptCreateProtectionDescriptor(descriptorString, 0, &handle)
	if !status.Success() {
		return nil, status
	}
	defer cryptosyscall.NCryptCloseProtectionDescriptor(handle)

	var pbOutput uintptr
	var chOutput uintptr
	status = cryptosyscall.NCryptUnprotectSecret(
		handle, cryptosyscall.NCRYPT_SILENT_FLAG, ciphertext, nil, 0, &pbOutput, &chOutput)
	if !status.Success() {
		return nil, status
	}
	defer cryptosyscall.LocalFree(pbOutput)

	plaintext := copyBuffer(unsafe.Pointer(pbOutput), chOutput)
	return plaintext, nil
}

func copyBuffer(ptr unsafe.Pointer, size uintptr) []byte {
	out := make([]byte, size)
	for i := range out {
		out[i] = *((*byte)(unsafe.Pointer(uintptr(ptr) + uintptr(i))))
	}
	return out
}

func legacyProtectSecret(plaintext []byte) ([]byte, error) {
	input := cryptosyscall.DATA_BLOB{
		Count: uint32(len(plaintext)),
		Data:  &plaintext[0],
	}
	prompt := cryptosyscall.CRYPTPROTECT_PROMPTSTRUCT{}
	out := cryptosyscall.DATA_BLOB{}
	err := cryptosyscall.CryptProtectData(&input, nil, nil, 0, &prompt,
		cryptosyscall.CRYPTPROTECT_UI_FORBIDDEN,
		&out)
	if err != nil {
		return nil, err
	}
	defer cryptosyscall.LocalFree((uintptr)(unsafe.Pointer(out.Data)))

	rv := copyBuffer(unsafe.Pointer(out.Data), uintptr(out.Count))
	return rv, nil
}

func legacyUnprotectSecret(ciphertext []byte) ([]byte, error) {
	input := cryptosyscall.DATA_BLOB{
		Count: uint32(len(ciphertext)),
		Data:  &ciphertext[0],
	}
	prompt := cryptosyscall.CRYPTPROTECT_PROMPTSTRUCT{}
	out := cryptosyscall.DATA_BLOB{}
	err := cryptosyscall.CryptUnprotectData(&input, nil, nil, 0, &prompt,
		cryptosyscall.CRYPTPROTECT_UI_FORBIDDEN,
		&out)
	if err != nil {
		return nil, err
	}
	defer cryptosyscall.LocalFree((uintptr)(unsafe.Pointer(out.Data)))

	rv := copyBuffer(unsafe.Pointer(out.Data), uintptr(out.Count))
	return rv, nil
}
